# 软件目录
## Python小工具软件
### PDF图片压缩软件
用于压缩pdf中的图片，以便能上传到文献阅读软件中进行分析和划词翻译等。

```python
import tkinter as tk
from tkinter import filedialog, ttk, messagebox
import fitz  # PyMuPDF
from PIL import Image, ImageTk
import io
import os
import json
import time
from collections import defaultdict

class PDFImageCompressorApp:
    def __init__(self, root):
        self.root = root
        self.root.title("PDF图片压缩工具 - 保持文本可选择性")
        self.root.geometry("1000x800")
        
        # 设置样式
        self.style = ttk.Style()
        self.style.theme_use('clam')
        
        # 变量初始化
        self.pdf_path = None
        self.pdf_document = None
        self.total_pages = 0
        self.compression_level = 50  # 默认压缩级别50%
        self.original_size = 0
        self.compressed_size_estimate = 0
        
        # 图片统计信息
        self.image_count = 0
        self.total_image_size = 0
        self.image_info_list = []  # 存储所有图片信息
        
        # 图片预览相关
        self.preview_photo = None
        
        # 创建UI
        self.create_widgets()
        
    def create_widgets(self):
        # 主框架
        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # 配置网格权重
        self.root.columnconfigure(0, weight=1)
        self.root.rowconfigure(0, weight=1)
        main_frame.columnconfigure(0, weight=1)
        main_frame.rowconfigure(1, weight=1)
        
        # 标题
        title_label = ttk.Label(main_frame, text="PDF图片压缩工具 - 保持文本可选择性", font=("Arial", 16, "bold"))
        title_label.grid(row=0, column=0, columnspan=2, pady=(0, 15))
        
        # 文件选择区域
        file_frame = ttk.LabelFrame(main_frame, text="PDF文件", padding="10")
        file_frame.grid(row=1, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))
        file_frame.columnconfigure(0, weight=1)
        
        self.file_label = ttk.Label(file_frame, text="未选择文件", foreground="gray")
        self.file_label.grid(row=0, column=0, sticky=tk.W, pady=(0, 10))
        
        ttk.Button(file_frame, text="选择PDF文件", command=self.select_pdf).grid(row=0, column=1, padx=(10, 0))
        
        # 文件信息区域
        info_frame = ttk.Frame(main_frame)
        info_frame.grid(row=2, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))
        
        self.file_info_label = ttk.Label(
            info_frame, 
            text="文件大小: -- | 页数: -- | 图片数量: --"
        )
        self.file_info_label.pack(side=tk.LEFT)
        
        # 主内容区域 - 两列布局
        content_frame = ttk.Frame(main_frame)
        content_frame.grid(row=3, column=0, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S))
        content_frame.columnconfigure(0, weight=2)  # 左侧权重2
        content_frame.columnconfigure(1, weight=1)  # 右侧权重1
        content_frame.rowconfigure(0, weight=1)
        
        # 左侧：图片列表和预览
        left_frame = ttk.LabelFrame(content_frame, text="PDF中的图片", padding="10")
        left_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S), padx=(0, 10))
        left_frame.columnconfigure(0, weight=1)
        left_frame.rowconfigure(1, weight=1)
        
        # 图片列表和预览的框架
        list_preview_frame = ttk.Frame(left_frame)
        list_preview_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        list_preview_frame.columnconfigure(0, weight=1)
        list_preview_frame.columnconfigure(1, weight=1)
        list_preview_frame.rowconfigure(0, weight=1)
        
        # 图片列表（左侧）
        list_frame = ttk.Frame(list_preview_frame)
        list_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S), padx=(0, 5))
        list_frame.columnconfigure(0, weight=1)
        list_frame.rowconfigure(0, weight=1)
        
        # 图片列表标签
        ttk.Label(list_frame, text="图片列表:", font=("Arial", 10, "bold")).grid(row=0, column=0, sticky=tk.W, pady=(0, 5))
        
        # 添加滚动条的图片列表
        list_container = ttk.Frame(list_frame)
        list_container.grid(row=1, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        list_container.columnconfigure(0, weight=1)
        list_container.rowconfigure(0, weight=1)
        
        # 创建Treeview显示图片列表
        columns = ("page", "index", "size", "dimensions", "format")
        self.image_tree = ttk.Treeview(
            list_container, 
            columns=columns, 
            show="headings",
            height=15
        )
        
        # 设置列标题
        self.image_tree.heading("page", text="页面")
        self.image_tree.heading("index", text="序号")
        self.image_tree.heading("size", text="大小")
        self.image_tree.heading("dimensions", text="尺寸")
        self.image_tree.heading("format", text="格式")
        
        # 设置列宽度
        self.image_tree.column("page", width=60)
        self.image_tree.column("index", width=60)
        self.image_tree.column("size", width=80)
        self.image_tree.column("dimensions", width=100)
        self.image_tree.column("format", width=80)
        
        # 添加滚动条
        scrollbar = ttk.Scrollbar(list_container, orient=tk.VERTICAL, command=self.image_tree.yview)
        self.image_tree.configure(yscrollcommand=scrollbar.set)
        
        self.image_tree.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        scrollbar.grid(row=0, column=1, sticky=(tk.N, tk.S))
        
        # 绑定选择事件
        self.image_tree.bind("<<TreeviewSelect>>", self.on_image_select)
        
        # 图片预览（右侧）
        preview_frame = ttk.LabelFrame(list_preview_frame, text="图片预览", padding="10")
        preview_frame.grid(row=0, column=1, sticky=(tk.W, tk.E, tk.N, tk.S), padx=(5, 0))
        preview_frame.columnconfigure(0, weight=1)
        preview_frame.rowconfigure(1, weight=1)
        
        # 图片信息
        self.preview_info_label = ttk.Label(preview_frame, text="选择图片查看预览")
        self.preview_info_label.grid(row=0, column=0, sticky=tk.W, pady=(0, 10))
        
        # 图片预览画布
        self.preview_canvas = tk.Canvas(
            preview_frame, 
            bg="white", 
            highlightthickness=1, 
            highlightbackground="gray",
            width=200,
            height=200
        )
        self.preview_canvas.grid(row=1, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # 右侧：压缩控制面板
        control_frame = ttk.LabelFrame(content_frame, text="压缩设置", padding="15")
        control_frame.grid(row=0, column=1, sticky=(tk.W, tk.E, tk.N, tk.S))
        control_frame.columnconfigure(0, weight=1)
        
        # 压缩级别滑块
        ttk.Label(control_frame, text="图片压缩级别:", font=("Arial", 10, "bold")).grid(
            row=0, column=0, sticky=tk.W, pady=(0, 5))
        
        scale_frame = ttk.Frame(control_frame)
        scale_frame.grid(row=1, column=0, sticky=(tk.W, tk.E), pady=(0, 10))
        
        ttk.Label(scale_frame, text="高压缩").pack(side=tk.LEFT)
        self.compression_scale = ttk.Scale(
            scale_frame, 
            from_=10, 
            to=95, 
            value=self.compression_level,
            command=self.update_compression_level
        )
        self.compression_scale.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=10)
        ttk.Label(scale_frame, text="高质量").pack(side=tk.LEFT)
        
        self.compression_value_label = ttk.Label(
            control_frame, 
            text=f"压缩质量: {100 - self.compression_level}%"
        )
        self.compression_value_label.grid(row=2, column=0, sticky=tk.W, pady=(0, 20))
        
        # 压缩选项
        options_frame = ttk.LabelFrame(control_frame, text="压缩选项", padding="10")
        options_frame.grid(row=3, column=0, sticky=(tk.W, tk.E), pady=(0, 20))
        
        # 最大尺寸限制
        size_limit_frame = ttk.Frame(options_frame)
        size_limit_frame.grid(row=0, column=0, sticky=(tk.W, tk.E), pady=(0, 5))
        
        ttk.Label(size_limit_frame, text="最大宽度:").pack(side=tk.LEFT)
        self.max_width_var = tk.StringVar(value="2000")
        max_width_entry = ttk.Entry(size_limit_frame, textvariable=self.max_width_var, width=8)
        max_width_entry.pack(side=tk.LEFT, padx=(5, 15))
        
        ttk.Label(size_limit_frame, text="最大高度:").pack(side=tk.LEFT)
        self.max_height_var = tk.StringVar(value="2000")
        max_height_entry = ttk.Entry(options_frame, textvariable=self.max_height_var, width=8)
        max_height_entry.grid(row=0, column=1, padx=(5, 0))
        
        # 格式选项
        self.convert_to_jpeg_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(
            options_frame, 
            text="转换为JPEG格式（更好的压缩）", 
            variable=self.convert_to_jpeg_var
        ).grid(row=1, column=0, columnspan=2, sticky=tk.W, pady=(5, 0))
        
        # 大小预估
        size_frame = ttk.LabelFrame(control_frame, text="大小预估", padding="10")
        size_frame.grid(row=4, column=0, sticky=(tk.W, tk.E), pady=(0, 20))
        
        self.original_size_label = ttk.Label(size_frame, text="原始大小: --")
        self.original_size_label.grid(row=0, column=0, sticky=tk.W)
        
        self.compressed_size_label = ttk.Label(size_frame, text="预估压缩后大小: --")
        self.compressed_size_label.grid(row=1, column=0, sticky=tk.W, pady=(5, 0))
        
        self.reduction_label = ttk.Label(size_frame, text="预估减少: --")
        self.reduction_label.grid(row=2, column=0, sticky=tk.W, pady=(5, 0))
        
        # 压缩按钮
        self.compress_button = ttk.Button(
            control_frame, 
            text="压缩并导出PDF", 
            command=self.compress_and_export,
            state=tk.DISABLED
        )
        self.compress_button.grid(row=5, column=0, pady=(0, 10))
        
        # 进度条
        self.progress = ttk.Progressbar(control_frame, mode='determinate')
        self.progress.grid(row=6, column=0, sticky=(tk.W, tk.E), pady=(0, 10))
        
        # 状态栏
        self.status_label = ttk.Label(
            main_frame, 
            text="就绪", 
            relief=tk.SUNKEN, 
            padding=(5, 2),
            anchor=tk.W
        )
        self.status_label.grid(row=4, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(10, 0))
    
    def select_pdf(self):
        """选择PDF文件"""
        file_path = filedialog.askopenfilename(
            title="选择PDF文件",
            filetypes=[("PDF文件", "*.pdf"), ("所有文件", "*.*")]
        )
        
        if file_path:
            try:
                self.pdf_path = file_path
                self.pdf_document = fitz.open(file_path)
                self.total_pages = len(self.pdf_document)
                
                # 更新文件信息
                self.file_label.config(text=os.path.basename(file_path))
                
                # 计算原始文件大小
                self.original_size = os.path.getsize(file_path)
                
                # 分析PDF中的图片
                self.analyze_pdf_images()
                
                # 更新大小预估
                self.update_size_estimate()
                
                # 更新图片列表
                self.update_image_list()
                
                # 启用压缩按钮
                self.compress_button.config(state=tk.NORMAL)
                
                # 更新状态
                self.status_label.config(text=f"已加载: {os.path.basename(file_path)}")
                
            except Exception as e:
                messagebox.showerror("错误", f"无法打开PDF文件: {str(e)}")
    
    def analyze_pdf_images(self):
        """分析PDF中的图片"""
        self.image_count = 0
        self.total_image_size = 0
        self.image_info_list = []
        
        if not self.pdf_document:
            return
        
        # 遍历所有页面提取图片信息
        for page_num in range(self.total_pages):
            page = self.pdf_document[page_num]
            
            # 获取页面中的所有图片
            image_list = page.get_images(full=True)
            
            for img_index, img_info in enumerate(image_list):
                xref = img_info[0]
                
                # 提取图片信息
                try:
                    base_image = self.pdf_document.extract_image(xref)
                    if base_image:
                        self.image_count += 1
                        image_size = len(base_image["image"])
                        self.total_image_size += image_size
                        
                        # 存储图片信息
                        image_info = {
                            "page": page_num,
                            "index": img_index,
                            "xref": xref,
                            "width": base_image["width"],
                            "height": base_image["height"],
                            "format": base_image["ext"],
                            "size": image_size,
                            "data": base_image["image"]
                        }
                        self.image_info_list.append(image_info)
                except Exception as e:
                    print(f"提取图片信息失败 (页面 {page_num}, 图片 {img_index}): {e}")
    
    def update_image_list(self):
        """更新图片列表显示"""
        # 清空现有列表
        for item in self.image_tree.get_children():
            self.image_tree.delete(item)
        
        # 添加图片信息到列表
        for i, img_info in enumerate(self.image_info_list):
            self.image_tree.insert(
                "", "end", 
                values=(
                    img_info["page"] + 1,
                    img_info["index"] + 1,
                    self.format_file_size(img_info["size"]),
                    f"{img_info['width']}×{img_info['height']}",
                    img_info["format"].upper()
                ),
                tags=(f"img_{i}",)
            )
    
    def on_image_select(self, event):
        """当选择图片列表中的项目时"""
        selection = self.image_tree.selection()
        if not selection:
            return
        
        # 获取选中的图片索引
        item = self.image_tree.item(selection[0])
        tags = item["tags"]
        if tags:
            img_index = int(tags[0].split("_")[1])
            self.display_image_preview(img_index)
    
    def display_image_preview(self, img_index):
        """显示图片预览"""
        if img_index < 0 or img_index >= len(self.image_info_list):
            return
        
        img_info = self.image_info_list[img_index]
        
        # 更新信息标签
        info_text = f"页面: {img_info['page'] + 1}, 图片: {img_info['index'] + 1}\n"
        info_text += f"尺寸: {img_info['width']}×{img_info['height']}\n"
        info_text += f"格式: {img_info['format']}\n"
        info_text += f"大小: {self.format_file_size(img_info['size'])}"
        
        self.preview_info_label.config(text=info_text)
        
        # 清空画布
        self.preview_canvas.delete("all")
        
        try:
            # 加载图片
            img_data = img_info["data"]
            img = Image.open(io.BytesIO(img_data))
            
            # 获取画布大小
            canvas_width = self.preview_canvas.winfo_width()
            canvas_height = self.preview_canvas.winfo_height()
            
            # 如果画布大小无效，使用默认值
            if canvas_width <= 1 or canvas_height <= 1:
                canvas_width = 200
                canvas_height = 200
            
            # 计算缩放比例
            img_ratio = img.width / img.height
            canvas_ratio = canvas_width / canvas_height
            
            if img_ratio > canvas_ratio:
                # 图片更宽，按宽度缩放
                new_width = canvas_width
                new_height = int(canvas_width / img_ratio)
            else:
                # 图片更高，按高度缩放
                new_height = canvas_height
                new_width = int(canvas_height * img_ratio)
            
            # 确保尺寸有效
            new_width = max(1, new_width)
            new_height = max(1, new_height)
            
            # 调整图片大小
            img_resized = img.resize((new_width, new_height), Image.Resampling.LANCZOS)
            
            # 转换为Tkinter格式
            self.preview_photo = ImageTk.PhotoImage(img_resized)
            
            # 在画布上显示
            x = (canvas_width - new_width) // 2
            y = (canvas_height - new_height) // 2
            self.preview_canvas.create_image(x, y, anchor=tk.NW, image=self.preview_photo)
            
        except Exception as e:
            print(f"预览图片失败: {e}")
            self.preview_canvas.create_text(
                100, 100, 
                text="预览不可用", 
                fill="gray", 
                font=("Arial", 12)
            )
    
    def update_compression_level(self, value):
        """更新压缩级别"""
        self.compression_level = int(float(value))
        
        # 压缩级别从10到95，对应质量从90到5
        quality = 100 - self.compression_level
        self.compression_value_label.config(text=f"压缩质量: {quality}%")
        self.update_size_estimate()
    
    def update_size_estimate(self):
        """更新大小预估"""
        if self.original_size > 0 and self.total_image_size > 0:
            # 计算非图片部分的大小
            non_image_size = self.original_size - self.total_image_size
            
            # 根据压缩级别计算压缩后的图片大小
            # 压缩级别从10%到95%，对应图片质量从90%到5%
            quality_factor = (100 - self.compression_level) / 100.0
            
            # 预估压缩比例
            compression_ratio = 0.5 + (quality_factor * 0.5)  # 0.5到1.0之间
            
            # 如果转换为JPEG，可能有更好的压缩
            if self.convert_to_jpeg_var.get():
                compression_ratio *= 0.7  # JPEG压缩效果更好
            
            # 如果有尺寸限制，可能会进一步减小
            try:
                max_width = int(self.max_width_var.get())
                max_height = int(self.max_height_var.get())
                
                # 简单估计：如果图片尺寸超过限制，会按比例缩小
                oversized_factor = 0.8  # 假设有20%的图片会超过限制
                compression_ratio *= (1 - 0.3 * oversized_factor)  # 降采样可能额外减少30%
            except:
                pass
            
            compressed_image_size = int(self.total_image_size * compression_ratio)
            
            # 计算预估的总大小
            self.compressed_size_estimate = non_image_size + compressed_image_size
            
            # 更新标签
            self.original_size_label.config(
                text=f"原始大小: {self.format_file_size(self.original_size)}"
            )
            self.compressed_size_label.config(
                text=f"预估压缩后大小: {self.format_file_size(self.compressed_size_estimate)}"
            )
            
            reduction = self.original_size - self.compressed_size_estimate
            if reduction > 0:
                reduction_percent = (reduction / self.original_size) * 100
                self.reduction_label.config(
                    text=f"预估减少: {self.format_file_size(reduction)} ({reduction_percent:.1f}%)"
                )
            else:
                self.reduction_label.config(text="预估减少: 无")
    
    def compress_and_export(self):
        if not self.pdf_path or not self.pdf_document:
            return
        
        save_path = filedialog.asksaveasfilename(
            title="保存压缩后的PDF",
            defaultextension=".pdf",
            filetypes=[("PDF文件", "*.pdf"), ("所有文件", "*.*")]
        )
        
        if not save_path:
            return
        
        try:
            # 重置进度条
            self.progress["value"] = 0
            self.progress["maximum"] = len(self.image_info_list)
            self.status_label.config(text="正在压缩PDF中的图片...")
            self.root.update()
            
            # 创建新的空白PDF文档作为输出
            output_doc = fitz.open()
            
            # 不直接复制页面，而是准备逐个页面重建
            for page_num in range(self.total_pages):
                # 获取原页面
                src_page = self.pdf_document.load_page(page_num)
                
                # 在新文档中创建相同尺寸的页面
                new_page = output_doc.new_page(width=src_page.rect.width, height=src_page.rect.height)
                
                # 将原页面内容显示到新页面
                new_page.show_pdf_page(new_page.rect, self.pdf_document, page_num)
                
            # 现在output_doc有了和原文档相同的页面结构
            # 处理每张图片
            processed_count = 0
            for i, img_info in enumerate(self.image_info_list):
                try:
                    # 压缩图片
                    compressed_data = self.compress_single_image(
                        img_info["data"],
                        img_info["format"],
                        img_info["width"],
                        img_info["height"]
                    )
                    
                    # 获取对应的页面
                    page = output_doc.load_page(img_info["page"])
                    
                    # 替换图片 - 使用旧的xref可能失效，所以需要重新查找
                    # 先获取当前页面中的所有图片
                    current_images = page.get_images(full=True)
                    
                    if img_info["index"] < len(current_images):
                        # 使用当前页面中对应索引的图片xref
                        current_xref = current_images[img_info["index"]][0]
                        page.replace_image(current_xref, stream=compressed_data)
                        processed_count += 1
                    else:
                        print(f"警告：页面 {img_info['page']} 的图片索引 {img_info['index']} 超出范围")
                    
                except Exception as e:
                    print(f"压缩图片失败 (页面 {img_info['page']}, 图片 {img_info['index']}): {e}")
                
                # 更新进度
                self.progress["value"] = i + 1
                progress_percent = (i + 1) / len(self.image_info_list) * 100
                self.status_label.config(text=f"正在压缩图片... {progress_percent:.1f}%")
                self.root.update()
            
            # 保存压缩后的PDF
            output_doc.save(save_path, garbage=4, deflate=True)
            output_doc.close()
        
            
            # 计算实际压缩后的大小
            actual_compressed_size = os.path.getsize(save_path)
            
            # 显示结果
            reduction = self.original_size - actual_compressed_size
            if reduction > 0:
                reduction_percent = (reduction / self.original_size) * 100
                
                messagebox.showinfo(
                    "压缩完成", 
                    f"PDF压缩完成！\n\n"
                    f"原始大小: {self.format_file_size(self.original_size)}\n"
                    f"压缩后大小: {self.format_file_size(actual_compressed_size)}\n"
                    f"减少: {self.format_file_size(reduction)} ({reduction_percent:.1f}%)\n"
                    f"处理图片: {processed_count}/{len(self.image_info_list)}\n\n"
                    f"文件已保存到:\n{save_path}\n\n"
                    f"注意：文本内容保持不变，可正常选择和复制。"
                )
            else:
                messagebox.showinfo(
                    "压缩完成", 
                    f"PDF处理完成！\n\n"
                    f"文件大小基本不变或略有增加。\n"
                    f"原始大小: {self.format_file_size(self.original_size)}\n"
                    f"处理后大小: {self.format_file_size(actual_compressed_size)}\n"
                    f"处理图片: {processed_count}/{len(self.image_info_list)}\n\n"
                    f"文件已保存到:\n{save_path}\n\n"
                    f"注意：文本内容保持不变，可正常选择和复制。"
                )
            
            self.status_label.config(text=f"压缩完成！已保存到: {os.path.basename(save_path)}")
            
        except Exception as e:
            messagebox.showerror("压缩错误", f"压缩过程中发生错误: {str(e)}")
            self.status_label.config(text="压缩失败")
    
    def compress_single_image(self, image_data, img_format, width, height):
        """压缩单张图片"""
        try:
            # 打开图片
            img = Image.open(io.BytesIO(image_data))
            
            # 计算压缩质量
            quality = 100 - self.compression_level
            quality = max(5, min(quality, 90))  # 确保在5-90范围内
            
            # 检查是否需要调整尺寸
            try:
                max_width = int(self.max_width_var.get())
                max_height = int(self.max_height_var.get())
                
                if width > max_width or height > max_height:
                    # 计算新的尺寸
                    width_ratio = max_width / width
                    height_ratio = max_height / height
                    ratio = min(width_ratio, height_ratio)
                    
                    new_width = int(width * ratio)
                    new_height = int(height * ratio)
                    
                    # 调整图片大小
                    img = img.resize((new_width, new_height), Image.Resampling.LANCZOS)
            except:
                pass
            
            # 输出格式
            output_format = "JPEG" if self.convert_to_jpeg_var.get() else img_format.upper()
            
            # 如果转换为JPEG且有透明通道，转换为RGB
            if output_format == "JPEG" and img.mode in ('RGBA', 'LA', 'P'):
                rgb_img = Image.new('RGB', img.size, (255, 255, 255))
                rgb_img.paste(img, mask=img.split()[-1] if img.mode == 'RGBA' else None)
                img = rgb_img
            
            # 保存压缩后的图片
            output = io.BytesIO()
            
            if output_format == "JPEG":
                img.save(output, format='JPEG', quality=quality, optimize=True)
            elif output_format == "PNG":
                # PNG压缩
                img.save(output, format='PNG', optimize=True)
            else:
                # 其他格式，尝试保持原格式
                img.save(output, format=img_format.upper())
            
            compressed_data = output.getvalue()
            
            return compressed_data
            
        except Exception as e:
            print(f"图片压缩失败: {e}")
            return image_data
    
    def format_file_size(self, size_bytes):
        """格式化文件大小显示"""
        if size_bytes < 1024:
            return f"{size_bytes} B"
        elif size_bytes < 1024 * 1024:
            return f"{size_bytes / 1024:.2f} KB"
        elif size_bytes < 1024 * 1024 * 1024:
            return f"{size_bytes / (1024 * 1024):.2f} MB"
        else:
            return f"{size_bytes / (1024 * 1024 * 1024):.2f} GB"

def main():
    root = tk.Tk()
    app = PDFImageCompressorApp(root)
    root.mainloop()

if __name__ == "__main__":
    main()
```
